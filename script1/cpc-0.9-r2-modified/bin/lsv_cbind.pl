#!/usr/bin/perl -w

use strict;
use warnings;

# combine two lsv file, columns by columns
# 
# NOTE: the code is rather d00dle: currently, only lsv generated by
# feat2libsvm.pl could be tested, USE IT CAREFULLY!

my $arg_lsv1 = shift @ARGV;
my $arg_lsv2 = shift @ARGV;

# (from libSVM README)
# <label> <index1>:<value1> <index2>:<value2> ...
# .
# .
# .

# <label> is the target value of the training data. For classification,
# it should be an integer which identifies a class (multi-class
# classification is supported). For regression, it's any real
# number. For one-class SVM, it's not used so can be any number. <index>
# is an integer starting from 1, <value> is a real number. The indices
# must be in an ascending order. The labels in the testing data file are
# only used to calculate accuracy or error. If they are unknown, just
# fill this column with a number.

my @lsv2_values;		# an array of refs
my @lsv2_labels;		# XXX: maybe empty

open LSV2, "<$arg_lsv2" or die "Can't open file ($arg_lsv2): $!";
while (my $l = <LSV2>) {
  chomp $l;
  my @fields = split /\s+/, $l;
  my $label = shift @fields;
  unless ($label =~ /^\d+:/) {
    push @lsv2_labels, $label;
  }
  else {
    # something like 1:20.3 --> not a label
    unshift @fields, $label;
  }

  my @values;
  foreach my $iv (@fields) {
    my ($index, $value) = split /:/, $iv;
    push @values, $value;
  }

  push @lsv2_values, \@values;
}
close LSV2;

open LSV1, "<$arg_lsv1" or die "Can't open file ($arg_lsv1): $!";

my $curr_line_no = 0;

while (my $l = <LSV1>) {
  chomp $l;
  my @fields = split /\s+/, $l;
  my $label = shift @fields;

  my $final_label = $lsv2_labels[$curr_line_no] || ""; # in case of "undef ..."
  
  unless ($label =~ /^\d+:/) {
    $final_label ||= $label;
    if ($final_label != $label) {
      warn "Wrong label for line $curr_line_no";
      $curr_line_no++;
      next;
    }
  }
  else {
    # something like 1:20.3 --> not a label
    unshift @fields, $label;
  }

  my @output_svm_line;
  push @output_svm_line, $final_label;

  my $final_index = 1;
  foreach my $iv (@fields) {
    my (undef, $value) = split /:/, $iv;
    push @output_svm_line, join(":", $final_index++, $value);
  }

  foreach (@{$lsv2_values[$curr_line_no]}) {
    push @output_svm_line, join(":", $final_index++, $_);
  }
  print join(" ", @output_svm_line), "\n";

  $curr_line_no++;
}
